#! /usr/bin/perl

use lib qw( /usr/local/freescore/lib );
use Clone qw( clone );
use Data::Structure::Util qw( unbless );
use Mojolicious::Lite;
use Mojo::IOLoop::Delay;
use JSON::XS;
use Digest::SHA1 qw( sha1_hex );
use FreeScore::Config;
use FreeScore::Security;
use FreeScore::Feats::Breaking::Division;
use FreeScore::Feats::Breaking;
use FreeScore::Feats::Breaking::RequestManager;
use FreeScore::Client::Registry;
use Try::Tiny;
use PHP::Session;
use Data::Dumper;
use List::Util;
use List::MoreUtils qw( first_index );

srand();

our $json     = new JSON::XS();
our $config   = new FreeScore::Config();
our $registry = new FreeScore::Client::Registry();

# ============================================================
websocket '/breaking/:tournament/:ring/:role' => sub {
# ============================================================
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring'       );
	my $client     = $registry->add( $self );
	my $manager    = new FreeScore::Feats::Breaking::RequestManager( $tournament, $ring, $client );
	my $progress   = undef;
	my $staging    = undef;

	$self->inactivity_timeout( 3600 ); # 1 hour
	$client->ping->start();

	# ----------------------------------------
	# Handle messages
	# ----------------------------------------
	$self->on( message => sub {
		my $self     = shift;
		my $request  = $json->decode( shift );
		my $security = new FreeScore::Security( $config );

		# ===== REJECT UNAUTHORIZED USERS
		if( $security->enabled()) {
			unless( $security->authenticated( $client ) && $security->authorized( $ring )) {
				$client->send({ json => { error => $security->unauthorized()}});
				return;
			}
		}

		$request->{ tournament } = $tournament;
		$request->{ ring }       = $ring;
		$request->{ from }       = { id => substr( $client->id(), 0, 4 ), sessid => substr( $client->sessid(), 0, 4 ), role => $client->role() };

		# ===== READ PROGRESS
		try   { 
			$progress = new FreeScore::Feats::Breaking( $tournament, $ring ); 
		} catch { $client->send( { json => { error => "Error reading database '$tournament', ring $ring: $_" }}); };

		# ===== HANDLE REQUEST
		try   { $manager->handle( $request, $progress, $client->group()); }
		catch { $client->send( { json => { error => "Error while processing request: $_\n", request => $request }}); };

		# ===== HEALTH CHECK ON ALL CLIENTS
		$manager->client_health_check( $ring, $client->group());
	});

	# ----------------------------------------
	# Handle websocket close
	# ----------------------------------------
	$self->on( finish => sub {
		my $request = { type => 'ring', action => 'leave', user => { sessid => $client->sessid(), id => $client->id(), role => $client->role() }};
		$registry->remove( $client );
		$manager->broadcast_updated_users( $request, $progress, $client->group());
		$client->ping->quit();
	});
};

# ============================================================
# JUDGE INTERFACE
# ============================================================

# ------------------------------------------------------------
# GET THE NUMBER OF JUDGES FOR THIS DIVISION
# ------------------------------------------------------------
get '/:tournament/:ring/judges' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );

	try {
		my $progress   = new FreeScore::Feats::Breaking( $tournament, $ring );
		my $division   = $progress->current();
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( json => { 'division' => $division->{ name }, 'judges' => $division->{ judges } } );

	} catch {
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( json => { error => $_ });
	}
};

# ============================================================
# ADMIN INTERFACE
# ============================================================

# ------------------------------------------------------------
# GET THE DIVISION INFORMATION AS JSON
# ------------------------------------------------------------
get '/:tournament/:ring/:divid/json' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );
	my $divid      = $self->param( 'divid' );

	try {
		my $progress   = new FreeScore::Feats::Breaking( $tournament, $ring );
		my $found      = $progress->find( $divid );
		my $division   = $found ? $found : $progress->current();
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( text => $division->to_json(), format => 'json' );

	} catch {
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( json => { error => $_ });
	}
};

# ------------------------------------------------------------
# GET THE DIVISION INFORMATION AS CSV
# ------------------------------------------------------------
get '/:tournament/:ring/:divid/csv' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );
	my $divid      = $self->param( 'divid' );

	try {
		my $progress   = new FreeScore::Feats::Breaking( $tournament, $ring );
		my $found      = $progress->find( $divid );
		my $division   = $found ? $found : $progress->current();
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( text => $division->to_csv(), format => 'txt' );

	} catch {
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( json => { error => $_ });
	}
};

# ------------------------------------------------------------
# WRITE NEW TOURNAMENT INFORMATION
# ------------------------------------------------------------
post '/:tournament/:ring/:divid' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );
	my $divid      = $self->param( 'divid' );
	my $json       = new JSON::XS();
	my $data       = $json->decode( $self->req->body());
	my $progress   = new FreeScore::Feats::Breaking( $tournament, $ring );
	my $division   = $progress->find( $divid );

	my $path  = sprintf( "%s/%s/%s/ring%02d", $FreeScore::PATH, $tournament, $FreeScore::Feats::Breaking::SUBDIR, $ring );
	$division = new FreeScore::Feats::Breaking::Division( $path, $divid, $ring ) unless( $division );

	try {
		if( $division->exists() && ! exists $data->{ overwrite } ) {
			$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
			$self->render( json => { division => $divid, status => 'exists' } );
			return;
		}
		foreach my $key (keys %{ $data->{ header }}) { 
			$data->{ header }{ $key } = $json->decode( $data->{ header }{ $key } ) if( $key eq 'brackets' );
			$division->{ $key } = $data->{ header }{ $key }; 
		}
		delete $division->{ mode } if( ! exists $data->{ header }{ mode } );
		my $athletes = [];
		foreach my $i ( 0 .. $#{ $data->{ athletes }} ) {
			my $athlete = { name => $data->{ athletes }[ $i ], index => $i, info => undef, scores => [] };
			my $j       = first_index { lc $_->{ name } eq lc $athlete->{ name } } @{ $division->{ athletes }};
			if( $j >= 0 ) { 
				my $found = $division->{ athletes }[ $j ];
				foreach my $key (qw( info scores )) { $athlete->{ $key } = $found->{ $key }; }
			}
			push @$athletes, $athlete;
		}
		$division->{ athletes } = $athletes;
		$division->write();
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( json => { division => $divid, status => 'saved' } );

	} catch {
		$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
		$self->render( json => { 'error' => $_ } );
	}
};

# ============================================================
# STATUS
# ============================================================
get '/status' => sub {
	my $self = shift;
	$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
	$self->render( text => 'OK' );
};

# ============================================================
# ERROR TRAPPING
# ============================================================
any '*' => sub {
	my $self = shift;
	$self->res->headers->header( 'Access-Control-Allow-Origin' => $config->host() );
	$self->render( json => { error => 'FreeScore Breaking Unknown command' } );
};

# ============================================================
# HYPNOTOAD SERVER
# ============================================================
mkdir '/var/log/freescore' unless -e '/var/log/freescore';
app->config( hypnotoad => { listen => [ 'http://*:3078' ], pid_file => '/var/run/breaking.pid', workers => 1 });
app->log( new Mojo::Log( path => '/var/log/freescore/breaking.log', level => 'error' ));
app->start();
